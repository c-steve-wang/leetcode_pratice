# Day 42&43

leetcode 188，309，714，300，

[leetcode 188](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)

这个地方其实是之前最多买卖两支股票的一个变种，就是用循环把两支五个情况扩展到k支 2*k个情况，主要是用循环初始化，并且用两重循环来迭代


```
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if len(prices) == 0:
            return 0 

        dp = [[0] * (2*k + 1) for _ in range(len(prices))]

        for i in range(1, 2*k, 2):
            dp[0][i] = -prices[0]

        for i in range(1, len(prices)):
            for j in range(0, 2*k - 1, 2):
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j+1] + prices[i])

        # print(dp)
        return dp[-1][2*k]
        
```    

[leetcode 309](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

这个地方主要是需要拆分保持卖出和卖出的状态，持有和冷冻期，相当于之前的两个状态需要拆成四个状态

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 0： keep
        # 1： keep sold
        # 2 ：sold today
        # 3: cd

        if len(prices) == 0:
            return 0

        
        dp = [[0] * 4 for _ in range(len(prices))]

        dp[0][0] = -prices[0]

        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i-1][0], dp[i - 1][3]-prices[i], dp[i-1][1]-prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-1][3])
            dp[i][2] = dp[i - 1][0] + prices[i]
            dp[i][3] = dp[i-1][2]

        n = len(prices)
        return max(dp[n-1][2], dp[n-1][1], dp[n-1][3])
```

[leetcode 714](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

这个地方没什么好说的，只要加上最基础的fee就可以了，需要注意的是一次完整的交易（买和卖，只需要一次手续费）
```
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        if len(prices) == 0:
            return 0

        dp = [[0]*2 for _ in range(len(prices)) ]

        dp[0][0] = -prices[0]
        
        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] -fee)

        return max(dp[len(prices) - 1][1],dp[len(prices) - 1][0] )

```
[leetcode 300](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

这个地方首先要注意两点，第一个是初始化过程中，最长子序列应该初始化成1 而不是0，因为最短长度是自身
第二个是这里的含义，是以 i 结尾的最长递增子序列的长度

```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] *len(nums)


        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)

        return max(dp)
```
[leetcode 674](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

这个地方是递增，有点类似于寻找路径那个题，主要还是需要根据前一个状态推，不像上面那个不完全依赖前一个状态（上面是依赖于子序列中的状态，反正不是严格前推后）

```
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        dp = [1] *len(nums)


        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                dp[i] = dp[i-1] + 1

        return max(dp)
```

[leetcode 718](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

这个地方主要理解 i - 1和 j - 1的含义，其实就是为了省略一步初始化的过程

然后对于二维dp数组，max返回的是一行，所以还应该在一行里面求最大值，或者直接循环里面计算

```
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        dp = [[0]* (len(nums2) + 1) for _ in range(len(nums1) + 1)]

        res= 0 
        for i in range(1, len(nums1) + 1):
            for j in range(1, len(nums2) + 1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                    res = max(dp[i][j], res) 

        return res
```
