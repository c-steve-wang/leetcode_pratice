
# Day 44&45

leetcode 1834, 1143


[leetcode 674](https://leetcode.com/problems/palindromic-substrings/description/)

这道题要注意的地方很多，首先dp数组只是判断是不是连续回文子串的， 然后再根据result弄，其次最重要的是遍历顺序，首先i肯定是从后往前遍历，因为是判断字串的前半部分，j判断是i向后的部分，所以只能从i开始

```
class Solution:
    def countSubstrings(self, s: str) -> int:
        dp = [[False]* len(s) for _ in range(len(s))]

        result = 0

        for i in range(len(s) - 1, -1 , -1):
            for j in range(i, len(s)):
                if s[i] == s[j]:
                    if j - i <= 1:
                        dp[i][j] = True
                        result += 1
                    elif dp[i+1][j-1] == True:
                        dp[i][j] = True
                        result += 1

        
        return result
               
```


[leetcode 674](https://leetcode.com/problems/palindromic-substrings/description/)

这个题的问题又是出现在了递归顺序上，因为i 和 j相同的情况已经初始化过了，所以要从后面一个开始计算
```
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        dp = [[0]* len(s) for _ in range(len(s))]

        for i in range(0, len(s)):
            dp[i][i] = 1

        for i in range(len(s) - 1, -1 , -1):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                     dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                     dp[i][j] = max(dp[i+1][j], dp[i][j- 1])

        
        return max(max(dp))
```


[leetcode 739](https://leetcode.com/problems/palindromic-substrings/description/)

单调栈的理解其实对我一点不复杂，很像逆波兰，主要这里面要stack不能初始化成空的，必须要有一个0
其次是while循环（这个很好理解），但while循环结束之后依然要push
不然没办法比较这个和后面的，这点事我个人容易忽略的点

```
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack = [0]

        ans = [0]*len(temperatures)

        for i in range(len(temperatures)):
            if temperatures[i] <= temperatures[stack[-1]]:
                stack.append(i)
            else:
                while len(stack) != 0 and temperatures[i] > temperatures[stack[-1]]:
                    ans[stack[-1]] = i - stack[-1]
                    stack.pop()
                stack.append(i)

        return ans
```
