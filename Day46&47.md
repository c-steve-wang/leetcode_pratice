
# Day 44&45

leetcode 1834, 1143


[leetcode 674](https://leetcode.com/problems/palindromic-substrings/description/)

这道题要注意的地方很多，首先dp数组只是判断是不是连续回文子串的， 然后再根据result弄，其次最重要的是遍历顺序，首先i肯定是从后往前遍历，因为是判断字串的前半部分，j判断是i向后的部分，所以只能从i开始

```
class Solution:
    def countSubstrings(self, s: str) -> int:
        dp = [[False]* len(s) for _ in range(len(s))]

        result = 0

        for i in range(len(s) - 1, -1 , -1):
            for j in range(i, len(s)):
                if s[i] == s[j]:
                    if j - i <= 1:
                        dp[i][j] = True
                        result += 1
                    elif dp[i+1][j-1] == True:
                        dp[i][j] = True
                        result += 1

        
        return result
               
```


[leetcode 674](https://leetcode.com/problems/palindromic-substrings/description/)

这个题的问题又是出现在了递归顺序上，因为i 和 j相同的情况已经初始化过了，所以要从后面一个开始计算
```
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        dp = [[0]* len(s) for _ in range(len(s))]

        for i in range(0, len(s)):
            dp[i][i] = 1

        for i in range(len(s) - 1, -1 , -1):
            for j in range(i+1, len(s)):
                if s[i] == s[j]:
                     dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                     dp[i][j] = max(dp[i+1][j], dp[i][j- 1])

        
        return max(max(dp))
```


[leetcode 739](https://leetcode.com/problems/palindromic-substrings/description/)

单调栈的理解其实对我一点不复杂，很像逆波兰，主要这里面要stack不能初始化成空的，必须要有一个0
其次是while循环（这个很好理解），但while循环结束之后依然要push
不然没办法比较这个和后面的，这点事我个人容易忽略的点

```
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack = [0]

        ans = [0]*len(temperatures)

        for i in range(len(temperatures)):
            if temperatures[i] <= temperatures[stack[-1]]:
                stack.append(i)
            else:
                while len(stack) != 0 and temperatures[i] > temperatures[stack[-1]]:
                    ans[stack[-1]] = i - stack[-1]
                    stack.pop()
                stack.append(i)

        return ans
```

[leetcode 496](https://leetcode.com/problems/palindromic-substrings/description/)

记录一下暴力写法，这个里面记得一定要break，然后从idx + 1开始
```
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        ans = [-1]* len(nums1)
        for i in nums1:
            if i in nums2:
                idx = nums2.index(i)
                for j in range(idx + 1, len(nums2)):
                    if nums2[j] > i:
                        ans[nums1.index(i)] = nums2[j]
                        break

        return ans
```

单调栈写法，这个里面最重要的就是搞清楚到底再index什么，然后因为事比他大的数字要存下来，所以最后的ans数组传入nums2[i]这点一定要认清
而且每次if之后都要pop，不是会卡在那，一直不弹出无法进行下一步
```
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        ans = [-1]* len(nums1)
        
        stack =  [0]

        for i in range(len(nums2)):
            if nums2[i] <= nums2[stack[-1]]:
                stack.append(i)
            else:
                while len(stack) != 0 and nums2[i] > nums2[stack[-1]]:
                    if  nums2[stack[-1]] in nums1:
                        ans[nums1.index(nums2[stack[-1]])] = nums2[i]
                    stack.pop()
                stack.append(i)

        return ans
```
[leetcode 503](https://leetcode.com/problems/next-greater-element-ii/)


这个地方要不断压入取模的下标而不是真实下标，这点才是循环里面最重要的，包括后面

```
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        ans = [-1]* len(nums)
        
        stack =  [0]

        for i in range(len(nums) * 2):
            if nums[i % len(nums)] <= nums[stack[-1]]:
                stack.append(i % len(nums))
            else:
                while len(stack) != 0 and nums[i % len(nums)] > nums[stack[-1]]:
                    ans[stack[-1]] = nums[i % len(nums)]
                    stack.pop()
                stack.append(i % len(nums))

        return ans
```


