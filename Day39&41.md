# 代码随想录Day39&41

leetcode 198，213，337，121，122， 123

[leetcode 198](https://leetcode.com/problems/house-robber/)

这里面要注意从哪开始迭代和初始化，这些具体都要根据题目的情况走


```
class Solution:
    def rob(self, nums: List[int]) -> int:
        # take current point or not
        # dp[i] max money take

        n = len(nums)
        dp = [0]* (n + 1)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, n):
            dp[i] = max(dp[i-2] + nums[i], dp[i - 1])


        return dp[n - 1]
        
```    
[leetcode 213](https://leetcode.com/problems/house-robber-ii/)

这个地方在处理边界条件的时候出了问题，两个函数都要考虑大小问题，之前1D的可以不考虑因为初始话已经考虑过了，但这里不行

```
class Solution:
    def robrange(self, list_t):
        n = len(list_t)
        if n == 0:
            return 0 
        if n == 1:
            return list_t[0]
        dp = [0]* (n + 1)
        dp[0] = list_t[0]
        dp[1] = max(list_t[0], list_t[1])

        for i in range(2, n):
            dp[i] = max(dp[i-2] + list_t[i], dp[i - 1])


        return dp[n - 1]

    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0 
        
        if len(nums) == 1:
            return nums[0]

        res_1 = self.robrange(nums[1:])
        res_2 =  self.robrange(nums[:-1])

        return max(res_1, res_2)
```

[leetcode 213](https://leetcode.com/problems/house-robber-iii/)

这个地方主要是练习树形dp怎么做
dp单纯定义几个独立的状态，然后根据状态求解
每一种状态对应着上一个状态的转移，虽然有点废话。树型dp大部分情况下都是后序遍历，因为要状态转移

然后底下这个写法list 和 tuple没有区别，就是省一点和多一点内存

```
class Solution:
    def traversal(self, node):
        if not node:
            return (0,0)
        
        left    = self.traversal(node.left)
        right   = self.traversal(node.right)

        val_0   = max(left[0], left[1]) + max(right[0], right[1])
        val_1   = node.val + left[0] + right[0]

        return (val_0, val_1)

    def rob(self, root: Optional[TreeNode]) -> int:
        # condition 1: take the parent and don't take any kids
        # condition 2: take ant of the kids but don't take the parent

        # dp[0] not steal this point
        # dp[1] steal this point
        dp = self.traversal(root)

        return max(dp)

```

[leetcode 121](https://leetcode.com/problems/house-robber/)

主要还是dp的老问题，初始化什么，初始化之后就不计入后面的循环了
而且因为只能卖一次，所以很多都是无限的


```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # dp[i][0] = keep
        # dp[i][1] = not keep

        dp = [[0]*2 for _ in range(len(prices))]
        dp[0][0] = -prices[0]
        dp[0][1] = 0

        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i - 1][0], -prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])

        return dp[len(prices) - 1][1] 
```
[leetcode 122](https://leetcode.com/problems/house-robber/)

这个地方稍微改动就好，但是要注意，这个地方只能持有一支股票
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
    
        # dp[i][0] = keep
        # dp[i][1] = not keep

        dp = [[0]*2 for _ in range(len(prices))]
        dp[0][0] = -prices[0]
        dp[0][1] = 0

        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i - 1][0], dp[i-1][1]-prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])

        return dp[len(prices) - 1][1] 


```
[leetcode 123](https://leetcode.com/problems/house-robber/)

这个地方难就难在四个状态到五个状态的初始化，尤其是多状态下dp怎么推，其他的倒是无所谓
还有边界条件的判断

```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if len(prices) == 0:
            return 0
        dp = [[0]*5 for _ in range(len(prices))]
        dp[0][1] = -prices[0]
        dp[0][3] = -prices[0]

        for i in range(1, len(prices)):
        # no operation 
            dp[i][0] = dp[i-1][0]
        # first keep
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
        # first not keep 
            dp[i][2] = max(dp[i-1][2], dp[i-1][1]+prices[i])
        # second keep
            dp[i][3] = max(dp[i-1][3], dp[i-1][2]-prices[i])
        # second not keep 
            dp[i][4] = max(dp[i-1][4], dp[i-1][3]+prices[i])

        
        return dp[- 1][4]
```
