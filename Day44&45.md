# Day 44&45

leetcode 1834, 1143

*这个题在代码随想录中没有出现，但是两次面试碰见了记录刷一下*
[leetcode 1834](https://leetcode.com/problems/single-threaded-cpu/description/)

这里面还是挺多注意的点的，首先是sorted怎么用， 然后enumerate是什么（这里主要是给tuple赋id）
然后heapq里面的heap push和heap pop代表什么，这里利用heap来实现优先队列
然后怎么操作多个元素，怎么用优先队列实现，以及现在是小根堆，大根堆怎么实现（取负数）

```
from heapq import heappush, heappop
class Solution:
    def getOrder(self, tasks: List[List[int]]) -> List[int]:

        arr = sorted([(t[0], t[1], i) for i, t in enumerate(tasks)])


        n = len(tasks)

        ans = []
        heap = []
        time = 0
        i = 0

        while i < n or heap:
            if not heap and time < arr[i][0]:
                time = arr[i][0]

            while i < n and arr[i][0] <= time:
                arr_t, run_t, idx = arr[i]
                heappush(heap, (run_t, idx))
                i += 1

            proc, idx = heappop(heap)
            time += proc
            ans.append(idx)

        return ans 
```
[leetcode 1143](https://leetcode.com/problems/longest-common-subsequence/description/)

首先这里耽误了一天就全忘了，这里最重要的是递推公式，在相等和不相等条件下的情况，这个也是子序列问题必须要掌握的东西

其次这里要注意迭代区间， 因为我们相当于是i-1的长度和j-1的长度，所以在这个地方上必须要多递归一次，确保他递归结束

```
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]

        if text1 == None or text2 == None:
            return 0 

        dp[0][0] = 0

        result = 0 

        for i in range(1, len(text1) + 1):
            for j in range(1, len(text2) + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])

                if dp[i][j] >= result:
                    result = dp[i][j]

        return result
```
[leetcode 1035]

这个地方想明白这也是一个最长相等子序列的问题就直接copy代码就行

```
class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        text1 = nums1; text2 = nums2
        dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]

        if text1 == None or text2 == None:
            return 0 

        dp[0][0] = 0

        result = 0 

        for i in range(1, len(text1) + 1):
            for j in range(1, len(text2) + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])

                if dp[i][j] >= result:
                    result = dp[i][j]

        return result

```
[leetcode 53](https://leetcode.com/problems/maximum-subarray/description/)

这个地方忽略了一个问题，每次比的应该是前一个状态加当前数值和当前数值本身，如果是0的话碰见小于零的情况就没办法了

```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        dp = [0]*len(nums)

        dp[0] = nums[0]

        for i in range(1, len(nums)):
            dp[i] = max(dp[i-1] + nums[i], nums[i])

        return max(dp)

```
[leetcode 53](https://leetcode.com/problems/is-subsequence/)

这个地方的巧妙之处在于，怎么通过相同子序列的长度来求删除的操作是否可以得到

这里最重要的就是你删掉一个字符相当于在状态里面增加一个字符，也就是说如果s是t的子序列，就可以得到

这里面还是犯了递归区间的错误，因为已经从1出发了，for循环要对应上

```
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:

        # dp[i][j] 在这里代表分别以i和j结尾的相同子序列的长度
        dp = [[0]* (len(t) + 1) for _ in range(len(s) + 1)]


        for i in range(1, len(s) + 1):
            for j in range(1, len(t) + 1):
                if s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = dp[i][j - 1]

        if dp[-1][-1] == len(s):
            return True
        
        return False
```

[leetcode 53](https://leetcode.com/problems/is-subsequence/)

这个地方其实主要一个是定义，一个就是初始化
定义的化就是考虑i和j最大相等的个数，然后dp数组模拟可能的情况
另外一个初始化，要考虑（0，0）的情况，这个情况下空集和空集可以向等，所以应该是1
```
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        # 这个地方就是考虑，在相等的时候，用或者不用这个元素的两种情况，然后在不相等的时候，删除多余元素的情况
        # j 在这里应该是不动的，因为不断回滚的只有s
        # 感觉这种hard 题自己是想不出来的，碰见就任命了

        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]

        for i in range(len(s)):
            dp[i][0] = 1

        for j in range(1, len(t)):
            dp[0][j] = 0

        for i in range(1, len(s) + 1):
            for j in range(1, len(t) + 1):
                if s[i-1] == t[j - 1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]

        return dp[-1][-1]
```
[leetcode 583](https://leetcode.com/problems/delete-operation-for-two-strings/description/)

感觉所有编辑距离类的题目首先要考虑的都是字符串的初始化，尤其是两个字符串互相为0的情况，这块面试的时候应该可以问提示
然后这里面的递推公式按照删除操作理解就可以
```
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]

        for i in range(len(word1) + 1):
            dp[i][0] = i # the option we need to delte if one is empty

        for j in range(len(word2) + 1):
            dp[0][j] = j 

        for i in range(1, len(word1) + 1):
            for j in range(1, len(word2) + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j] + 1, dp[i][j - 1] + 1, dp[i-1][j-1] + 2)

        return dp[-1][-1]
        
```

[leetcode 72](https://leetcode.com/problems/edit-distance/)

这个地方注意递推公式，删除和添加等价，都是删除一个元素然后添加一个操作，替换的化那前面的都是完全相同的，所以添加一个操作就可以了

```
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]

        for i in range(len(word1) + 1):
            dp[i][0] = i # the option we need to delte if one is empty

        for j in range(len(word2) + 1):
            dp[0][j] = j 

        for i in range(1, len(word1) + 1):
            for j in range(1, len(word2) + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j] + 1, dp[i][j - 1] + 1, dp[i-1][j-1] + 1)

        return dp[-1][-1]
```

