# Day 46&48

leetcode 1834, 1143


[leetcode 42](https://leetcode.com/problems/trapping-rain-water/)

首先这里面要注意left， midle，right分别是什么，因为栈内单调递增，所以倒数第二个元素一定是比栈顶大的，当前元素又比栈顶大，正好形成界雨水的槽
同时等于的情况不需要考虑，因为无论在哪都不影响结果
最后是宽度的计算，是right- left - 1（带入数字计算一下），因为两边都不能算进去，只有中间的部分， r - f + 1是带上两个端点的

```
class Solution:
    def trap(self, height: List[int]) -> int:
        stack = [0]
        result = 0

        for i in range(len(height)):
            if height[i] <= height[stack[-1]]:
                stack.append(i)

            else:
                while stack and  height[i] > height[stack[-1]] :
                    mid_height = height[stack[-1]]
                    stack.pop()
                    if stack:
                        right_height = height[i]
                        left_height = height[stack[-1]]
                        h = min(left_height, right_height) - mid_height
                        w = i - stack[-1] - 1
                        result += w * h
                stack.append(i)

        return result

```

[leetcode 84](https://leetcode.com/problems/trapping-rain-water/)

相比于上一道题其实思路一样，只是要换成单调递减的栈，因为下一个坐标对应的位置一定比他小
然后这道题里面还要注意数组前后要增加一个0（最小值），避免因为一直数组元素递增无法出栈，造成结果无法遍历
最后是我的问题，一定要注意目前在处理的数组，我这个地方复制了一个新数组，但是遍历的时候还是遍历旧数组， 导致出现问题

```
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        height = [0] + heights + [0]
        

        result = 0
        stack = [0]

        for i in range(1, len(height)):
            if height[i] >= height[stack[-1]]:
                stack.append(i)
            else: 
                while stack and height[i] < height[stack[-1]]:
                    mid_height = height[stack[-1]]
                    stack.pop()
                    if stack:
                        # left_height = height[stack[-1]]
                        # right_height = height[i]
                        temp_res = mid_height * (i - stack[-1] -1)

                        result = max(temp_res, result)
                
                stack.append(i)
        
        return result

```

[leetcode 797](https://leetcode.com/problems/trapping-rain-water/)

这道题犯了一个写错误，要append list(path)，相当于复制了一遍，不然会根据递归改动

其次一定要初始化成0，因为严重依赖path是零开头的，如果没有所有的就不会有0，毕竟for 循环开始就会找0的下一个结点

```
class Solution:
    def dfs(self, graph, cur, target, path, res):
        if cur == target:
            res.append(list(path))
            return
            
        for i in graph[cur]:
            path.append(i)
            self.dfs(graph, i, target, path, res )
            path.pop()


        

    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        res = []
        path = [0]
        target = len(graph) - 1
        self.dfs(graph, 0, target ,path, res)

        return res
```
