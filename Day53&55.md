# Day 53&55

leetcode 127, 463，841

[leetcode 127]

这道题还是不要盲目的代码随想录的解决方法（毕竟我们的重点是leetcode），主要是理解思路，相当于每次替换一个字母就是一个路径，广搜当前的每一个路径

另外记住广搜循环里面一定是要处理pop出来的，这样才能保障搜索往下进行，这次又犯了这个错误

最后注意deque的应用，应该先定义list，后面append直接加元素就可以


```
from collections import deque
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordset = set(wordList)
        if endWord not in wordset:
            return 0   
        que = deque([[beginWord, 1]])

        while que:
            word, step = que.popleft()
            if word == endWord:
                return step

            for i in range(len(word)):
                for c in "abcdefghijklmnopqrstuvwxyz":
                    newword = word[:i] + c + word[i+1:]
                    if newword in wordset:
                        que.append([newword, step + 1])
                        wordset.remove(newword)

        return 0 
        

```

岛屿周长不需要搜索，直接判断四个方向即可

[leetcode 1971](https://leetcode.com/problems/find-if-path-exists-in-graph/description/)

并查集这里其实就理解两个核心：1.两个元素是否在同一个集合里面（公用父节点）2，如果不是，怎么利用list将两个元素添加进去

这里稍微注意一下其实还有一个按秩分解的优化思路，但是因为没什么必要现在，直接跳过

```
class Solution:

    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        father = list(range(n))

        def find(a):
            if a == father[a]:
                return a 
            else:
                father[a] = find(father[a])
                return father[a] 

        def union(a, b):
            a = find(a)
            b = find(b)
            if a == b:
                return
        
            father[a] = b
        
        for edge in edges:
            union(edge[0], edge[1])

        return find(source) == find(destination)
```
