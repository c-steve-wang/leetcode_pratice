# Day 51&52

[leetcode 200](https://leetcode.com/problems/number-of-islands/)
思路还是很简单的，找到一个为1的点然后开始做dfs，最主要的当前的点要换成visit = True
不然还是很容易出错的

bfs的版本里面，除了设置true，要记得一定要用弹出的，不然不会走到下一个点，只会一直遍历起点周围，和dfs不同，正是因为不同的点入队出队才可以的

然后一入队列就要设置为true，防止重复入队超时
```
class Solution:
    def dfs(self, grid, visit, x, y ):
        dirction = [[1,0], [0, 1], [-1, 0], [0, -1]]
        

        for direct in dirction:
            next_x = x + direct[0]
            next_y = y + direct[1]
            if next_x >=  len(grid) or next_x < 0 or next_y >=  len(grid[0]) or next_y < 0:
                continue
            
            if grid[next_x][next_y] == '1' and visit[next_x][next_y] == False:
                visit[next_x][next_y] = True
                self.dfs(grid, visit, next_x, next_y )

    def bfs(self, grid, visit, x, y ):
        dirction = [[1,0], [0, 1], [-1, 0], [0, -1]]
        
        from collections import deque

        que = deque([])
        visit[x][y] = True
        que.append([x,y])

        while que:
            cx, cy = que.popleft()
            for direct in dirction:
                next_x = cx + direct[0]
                next_y = cy + direct[1]
                if next_x >=  len(grid) or next_x < 0 or next_y >=  len(grid[0]) or next_y < 0:
                    continue
            
                if grid[next_x][next_y] == '1' and visit[next_x][next_y] == False:
                    visit[next_x][next_y] = True
                    que.append([next_x, next_y])

    def numIslands(self, grid: List[List[str]]) -> int:
        
        visit = [[False] * (len(grid[0])) for _ in range(len(grid))]
        result = 0 


        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1' and visit[i][j] == False:
                    result += 1
                    visit[i][j] = True
                    self.dfs(grid,visit, i, j)

        return result
```

[leetcode 695](https://leetcode.com/problems/max-area-of-island/description/)       

这个地方要注意最重要的一点就是看题目里面的判断，如果是判断当前结点，count写在dfs里面，主函数初始化为0；如果是判断next结点，count的初始化为一在主函数里面。
重点是区分到底在哪

其次是我犯的错误，要读题，看看具体的数据类型
然后如果用全局变量的话，count在dfs和主函数都要定义成global
        
```
count = 0

class Solution:

    def dfs(self, grid, visit, x, y):
        dirction = [[1,0], [0, 1], [-1, 0], [0, -1]]
        global count

        for direct in dirction:
            next_x = x + direct[0]
            next_y = y + direct[1]
            if next_x >=  len(grid) or next_x < 0 or next_y >=  len(grid[0]) or next_y < 0:
                continue
            
            if visit[next_x][next_y] == False and grid[next_x][next_y] == 1:
                count += 1
                visit[next_x][next_y] = True
                self.dfs(grid, visit, next_x, next_y)


    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        global count
        visit = [[False] * (len(grid[0])) for _ in range(len(grid))]
 

        res = 0 
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1 and visit[i][j] == False:
                    count = 1
                    visit[i][j] = True
                    self.dfs(grid,visit, i, j)
                    res = max(count, res)

        return res

```
