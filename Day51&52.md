# Day 51&52

[leetcode 200](https://leetcode.com/problems/number-of-islands/)
思路还是很简单的，找到一个为1的点然后开始做dfs，最主要的当前的点要换成visit = True
不然还是很容易出错的

bfs的版本里面，除了设置true，要记得一定要用弹出的，不然不会走到下一个点，只会一直遍历起点周围，和dfs不同，正是因为不同的点入队出队才可以的

然后一入队列就要设置为true，防止重复入队超时
```
class Solution:
    def dfs(self, grid, visit, x, y ):
        dirction = [[1,0], [0, 1], [-1, 0], [0, -1]]
        

        for direct in dirction:
            next_x = x + direct[0]
            next_y = y + direct[1]
            if next_x >=  len(grid) or next_x < 0 or next_y >=  len(grid[0]) or next_y < 0:
                continue
            
            if grid[next_x][next_y] == '1' and visit[next_x][next_y] == False:
                visit[next_x][next_y] = True
                self.dfs(grid, visit, next_x, next_y )

    def bfs(self, grid, visit, x, y ):
        dirction = [[1,0], [0, 1], [-1, 0], [0, -1]]
        
        from collections import deque

        que = deque([])
        visit[x][y] = True
        que.append([x,y])

        while que:
            cx, cy = que.popleft()
            for direct in dirction:
                next_x = cx + direct[0]
                next_y = cy + direct[1]
                if next_x >=  len(grid) or next_x < 0 or next_y >=  len(grid[0]) or next_y < 0:
                    continue
            
                if grid[next_x][next_y] == '1' and visit[next_x][next_y] == False:
                    visit[next_x][next_y] = True
                    que.append([next_x, next_y])

    def numIslands(self, grid: List[List[str]]) -> int:
        
        visit = [[False] * (len(grid[0])) for _ in range(len(grid))]
        result = 0 


        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1' and visit[i][j] == False:
                    result += 1
                    visit[i][j] = True
                    self.dfs(grid,visit, i, j)

        return result
```

        
        
